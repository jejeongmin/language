어떤 라이브러리는 한 인터페이스에서 리턴한 정보를 다른 곳에 전달하기 위해 클라이언트 코드에서 보관하도록 구성한 것도 있다.
이렇게 보관하는 정보를 Handle 이라 부르는데, 라이브러리에서 여러 함수나 메서드를 호출하는 과정에서 상태를 유지해야 하는
특정 인스턴스를 구현하는데 주로 사용된다. 그래서 보통 인스턴스에 대한 void* 캐스팅을 담은 값을 Handle 이라는 형태로 취하게 된다.
라이브러리에서 핸들을 사용하도록 디자인할 때는 내부 구현 사항을 드러내면 안된다.
이러한 핸들은 그래서 불투명(opaque) 클래스로 구현한다.

라이브러리의 한 컴포넌트는 반드시 한 작업만 처리하거나, 여러 작업을 처리하더라도 비슷한 기능의 것들만 처리하도록 디자인해야 한다.
다시 말해 응집도(cohesion ) 를 높이는데 주력해야 한다.
이를 단일책임성의 원칙(Single Responsibility Principle, SRP) 라고 부른다.

서브시스템을 디자인할 때는 반드시 독립적으로 재사용할 수 있는 컴포넌트로 만들어야 한다.
다시 말해 최대한 결합도(coupling)을 낮게 만든다.

템플릿을 사용해서 제너릭프로그래밍을 하는 경우에는 타입에 안전하다는 장점이 있다.
반면 문법이 복잡하고, 동형(homogeneous) 데이터 구조만 지원한다는 단점이 있다.
c++17 부터는 std::variant 나 std::any 객체등을 활용해 이런 제약을 우회하는 방법을 제공한다.

vector 에서 [] 는 빠른 접근이 가능한 대신 경계값 검사를 수행하지 않는다.
그러나 at 는 경계값 검사를 지원한다.
라이브러리 인터페이스를 만들 때는 이와 같이 다양한 사용사례에 대응하기 위한 인터페이스를 다수 제공하는 것도 좋다.

객체지향 디자인의 기본원칙을 기억하기 쉽도록 흔히 SOLID 란 약어로 표현한다.

S	SRP	Single Responsibility Principle		컴포넌트마다 하나의 잘 정의된 책임을 가지며 관련 없는 기능은 합치지 않는다.
O	OCP	Open/Close Principle			클래스는 상속을 통한 확장에는 개방적이고, 수정에는 폐쇄적이어야 한다.
L	LSP	Liskov Substitution Principle		어떤 객체의 자리를 그 객체의 서브타입 인스턴스로 치환할 수 있어야 한다.
I	ISP	Interface Segregation Principle		인터페이스는 깔끔하고 간결해야 한다. 거대한 범용 인터페이스보다는 작지만 한 가지 책무라도 잘 정의된 인터페이스를 여러 개로 구성하는 것이 낫다.
	DIP	Dependency Inversion Principle		인터페이스로 의존 관계를 역전시킨다. 의존성 주입은 의존성 역전 법칙을 구현하기 위한 방법 중 하나이다.
