함수 try block 을 생성자에 적용할 때는 다음과 같은 점을 주의 한다.

1. catch 문은 생성자 이니셜라이저나 생성자 본문에서 발생한 익셉션을 잡아서 처리한다.
2. catch 문은 반드시 현재 발생한 익셉셥을 다시 던지거나, 새 익셉셥을 만들어 던져야 한다. catch 문에서 이렇게 처리하지 않으면 런타임이 자동으로 현재 익셉셥을 다시 던진다.
3. catch 문은 생성자에 전달된 인수에 접근할 수 있다.
4. catch 문이 함수 try 블럭에서 익셉셥을 잡으면 생성자의 실행을 정상적으로 마친 베이스 클래스나 그 객체로 된 멤버는 catch 문을 시작하기 전에 소멸된다.
5. catch 문 안에서는 객체로 된 멤버 변수에 접근하면 안된다. 바로 앞에서 설명한 것처럼 catch 문이 실행되기 전에 소멸되기 때문이다.
   그런데 익셉션이 발생하기 전에 그 객체에 논클래스 타입(ex:일반 포인터)를 초기화했다면 여기에는 접근할 수 있다.
   단 이런 리소스 정리 작업은 catch 문에서 처리해야 한다. 이 프로젝트의 예시코드가 그렇게 처리하고 있다.
		코드를 작성해보니 멤버 변수에 접근 자체를 할 수 없다는 게 아니라, 멤버 객체에 값이 유효하지 않다는 의미이다.
6. 함수 try 블럭에 있는 catch 문은 그 안에 담긴 함수에서 값을 리턴할 때 return 키워드를 사용할 수 없다. 당연하지.. 원래 생성자는 return 을 사용할 수 없으니까.



소멸자에서 익셉션을 처리하는 방법

소멸자에서 발생하는 에러는 반드시 소멸자 안에서 처리해야 한다.
소멸자에서 익셉셥을 다른 곳으로 던지면 안된다.
그 이유는 다음과 같다.

1. 소멸자를 명시적으로 noexcept(false) 로 지정하지 않거나, 그 클래스에 있는 객체 중 소멸자에서 noexcept(false)가 지정된 것이 없다면,
	내부적으로 noexcept 로 선언된 것으로 취급한다. noexcept 소멸자에서 exception 을 던지면 c++ 런타임은 std::terminate 를 호출해서 프로그램을 종료한다.
2. 소멸자는 다른 익셉셥이 발생해서 스택 풀기를 수행하는 과정에서 실행될 수도 있다. 스택 풀기를 하는 도중에 소멸자에서
	익셉셥을 던지면 c++ 런타임은 std::exception 을 호출해서 프로그램을 종료한다. -> tcwebgateway 가 라이브에서 그때 크래시 난 게 이 사례가 아닐까 의심.
3. 프로그래머가 소멸자를 직접 호출하지 않고, delete 를 이용하여 간접적으로 소멸자를 호출한다. 그런데 소멸자에서 익셉셥을 던지면 프로그래머는 어떻게 처리 한단 말인가?
	이미 delete 를 호출한 객체에 다시 delete 를 호출할 수 없고, 소멸자를 직접 호출할 수도 없다. 이렇게 프로그래머가 할 수 있는 일이 없기 때문에
	굳이 익셉셥 처리의 부담을 줄 이유가 없다.
4. 소멸자는 객체에서 사용할 메모리나 리소스를 해제할 마지막 기회다. 함수 실행 도중에 익셉셥을 던져 이 기회를 놓쳐버리면 다시 돌아가 메모리나 리소스를 해제할 수 없다.