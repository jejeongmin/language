#pragma once

#include <functional>
#include <memory>

class Widget7
{
public:
	Widget7() {};
	Widget7(int i, bool b) {};
	Widget7(int i, double d) {};
	Widget7(std::initializer_list<long double>) {};
	
	// 컴파일러가 자신의 결심을 포기하고 보통의 오버로딩 함수 선택으로 물러나는 경우는 아래 코드와 같이
	// 중괄호 초기치의 인수 형식들을 std::initializer_list 안의 형식으로 변환하는 방법이 아예 없을 뿐이다.
	// Widget7(std::initializer_list<string>) {};

	int		x{ 0 };
	int		y = 0;
	//int		z(0);
};

/*********************************************************
객체 생성 시 괄호() 와 중괄호{}를 구분하라

어찌되었건 책에서는 둘 중 하나를 선택해서 일관되게 적용하라는 것이다.
난 두말할 것 없이 () 를 기본으로 사용하고, 중괄호 초기치 적용은 괄호 안에서 병행해서
중괄호 초기치를 명확히 드러내는 형식으로 명시해서 쓰는 것이 좋다고 생각한다.

**********************************************************/
class chapter07 : public chapter
{
	virtual int chapterMain()
	{
		int x1(0);			// 초기치를 괄호로 감싼 예
		int x2 = 0;			// 초기치를 '=' 다음에 지정한 예
		int x3{ 0 };		// 초기치를 중괄호로 감싼 예
		int x4 = { 0 };		// '='와 중괄호로 초기치를 지정한 예

		// int 와 같은 내장형식에서는 초기화와 배정은 그냥 학술적인 차원에서만 차이가 나지만,
		// 사용자 정의 형식에서는 초기화와 배정이 각자 다른 함수들을 호출하므로 둘을 구분하는 것이 중요하다.
		Widget7	w1;			// 기본 생성자를 호출
		Widget7	w2 = w1;	// 배정이 아님. 복사 생성자를 호출
		w1 = w2;			// 배정 연산자(operator =)를 호출

		std::vector<int> v{ 1, 3, 5 };	// 중괄호를 이용한 균일 초기화, 혹은 중괄호 초기화

		// 위 시점까지 보면, 초기화를 하는 방법 중 컴파일 오류를 유발하지 않고 가장 폭넓게 사용되는 것은
		// 괄호() 나 배정= 이 아닌, 중괄호{} 임을 알 수 있다.

		// 더욱이 중괄호는 아래 코드에서 보듯 좁히기 변환(narrow conversion)을 방지한다.
		double	x(0), y(0), z(0);
		//int		sum1{ x + y + z };	build fail

		int	sum2 = x + y + z;		// 적용되나 값이 절삭될 수 있음
		int sum3(x + y + z);		// 위와 상동

		Widget	a1();				// 사실은 변수 정의였으나, 함수 정의로 오해할 수 있다. vs2015는 컴파일러가 똑똑해서 이런 구문을 warning 으로 정확히 알려준다.
		Widget	a2{};				// 중괄호로 기본 생성자를 이용해 변수 정의, 이러면 위와 같은 오해의 여지가 없다.

		// 위와 같이 중괄후를 사용한 초기화의 장점이 많음에도 불구하고 중괄호를 적극 권고하지 않는 이유가 있다.
		// 첫째 auto 로 선언된 변수에 대해서는 std::initializer_list 형식으로 연역되는 경우가 많다.
		// 그래서 auto 를 좋아하면 할수록 중괄호 초기화를 점점 멀리하는 경향이 생기게 된다.
		Widget7	t1(10, true);
		Widget7	t2{ 10, true };		// 중괄호를 사용할 경우, 더 적합한 오버로딩군 함수가 있음에도 std::initializer_list 함수를 선택하게 된다
		Widget7	t3(10, 5.0);
		Widget7	t4{ 10, 5.0 };		// 중괄호 초기치에 대응시키고자 하는 컴파일러의 우선 순위 정책이 너무나 강하기 때문이다.
		// 바로 위 코드에서 보듯, std::initializer_list 오버로딩은 그냥 다른 오버로딩과 경쟁하는 것이 아니라, 다른 오버로딩을
		// 고려 대상에서 거의 완전히 제외될 정도로 가벼 버린다.

		// 기본 생성을 지원하며, std::initializer_list 생성도 지원하는 객체를 빈 중괄호 쌍으로 생성한다고 하자.
		// 컴파일러는 빈 중괄호쌍을 어덯게 받아들일까?
		// 표준에 따르면 기본 생성자가 호출된다.

		Widget7 p1;			// 기본 생성자를 호출
		Widget7 p2{};		// 역시 기본 생성자를 호출
		Widget7 p3({});		// std::intializer_list 생성자를 빈 초기치 목록으로 호출
		Widget7 p4{ {} };	// 위와 상동

		// 도대체 위와 같은 개떡같은 개념 차이를 일상 프로그래밍에서 어디에 써먹는다는 말인가?
		// 저자의 말에 의하면 vector 에 가장 많이 사용된다고 한다.
		std::vector<int>	v1(10, 20);		// 값이 20인, 요소 10개가 삽입
		std::vector<int>	v2{ 10, 20 };	// 10, 20 두 개의 요소가 intializer_list 초기화로 인해 삽입
		// 기껏 생각해 낸 자주 사용하는 용례가 이 정도라니... 이건 기억해둘 가치가 별로 없네..
		// 문제 생길 때 디버깅을 통해 확인하는 게 더 낫겠다.


		return 0;
	}
};

/*
	중괄호 초기화는 가장 광범위하게 적용할 수 있는  초기화 구문이며, 좁히기 변환을 방지하며,
	c++ 의 가장 성가신 구문 해석에서 자유롭다.

	생성자 중복적재 해소 과정에서 중괄호 초기화는 가능한 한 std::initializer_list 매개 변수가 있는
	생성자와 부합한다.(심지어 겉으로 보기에 그보다 인수들에 더 잘 부합하는 생성자들이 있음에도 불구하고)

	괄호와 중괄호의 선택이 의미 있는 차이를 만드는 예는 인수 두 개로 std::vector<수치형식>을 생성하는 것이다.

	템플릿 안에서 객체를 생성할 때 괄호를 사용할 것인지 중괄호를 사용할 것인지 선택하기가 어려울 수 있다.
*/